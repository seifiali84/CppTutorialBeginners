
# مقدمه

داخل قسمت بعدی مثال فروشگاه کامپیوتر رو با موفقیت کامل کردیم. داخل این قسمت همزمان باید گرفتن مباحث جدید قراره مثال مدیریت آزمون های قلمچی رو پیاده سازی کنیم که مطالب بهتر جا بیوفتن.

داخل این قسمت میفهمیم که چرا اون public رو داخل کلاس هامون مینوشتیم و با متد سازنده یا کانستراکتور(constructor) آشنا میشیم.

# متد سازنده (Constructor Method)

لحظه ای که ما از یک کلاس نمونه گیری می کنیم داخل اون کلاس یک تابع یا همون متدی اجرا میشه که بهش کانستراکتور یا متد سازنده میگن. کار این متد اینه که آبجکت مارو بسازه و اگر لازمه مقادیر اولیه ای رو برای اون تایین کنه.

قضیه اونجایی جالب میشه که ما میتونیم اون متد رو خودمون به صورت دستی تعریف کنیم و در هنگام ساخته شدن یک آبجکت دستورات خاصی رو اجرا کنیم.

با توجه به اینکه با ویژگی های استاتیک آشنایی پیدا کردید می خوایم یه حرکت جالب بزنیم که بهتر با این مفهوم آشنایی پیدا کنید.

ما میایم و یک ویژگی استاتیک از نوع `int` داخل کلاسمون میزاریم که قراره تعداد آبجکت های ساخته شده از کلاسمون رو برامون نگه داره. حالا میایم و داخل متد سازنده ی این کلاس میگیم که هربار یک آبجکت ساخته میشه یه واحد به اون ویژگی ما اضافه کنه و در نهایت ما از طریق اون ویژگی استاتیک میتونیم تعداد آبجکت های ساخته شده رو به دست بیاریم.

اول با طریقه ی تعریف کانستراکتور آشنا میشیم :

```cpp
class MyClass {     // The class  
  public:           // Access specifier  
    MyClass() {     // Constructor  
      cout << "Hello World!";  
    }  
};  
  
int main() {  
  MyClass myObj;    // Create an object of MyClass (this will call the constructor)  
  return 0;  
}
```
برای تعریف کانستراکتور شما باید تابعی دقیقا با اسم کلاستون تعریف کنید و نیازی هم نیست که void اول اون رو بنویسید و فقط باید اسم تابع رو بنویسید.

و داخل بدنه ی اون تابع هر دستوری که بزارید موقع ساختن آبجکت از اون تابع اون دستور اجرا میشه.
یعنی داخل اولین دستور از بدنه ی اصلی برنامه که نمونه گیری انجام شده این تابع کانستراکتوری که ما تعریف کردیم هم اجرا میشه.

حالا بیاید و با همین شناختی که تا اینجا نسبت به کانستراکتور پیدا کردیم یک شمارنده ی تعداد آبجکت ها برای کلاسمون تعریف کنیم.

اسم کلاسمون رو برای مثال Human میزاریم که داخلش تعداد انسان هایی که توی برنامه مون ساخته شده رو بشماریم :

```cpp
class Human
{
public:
    string Name;
    string Family;
  
    static int Count;
    
	// Constructor
    Human()
    {
        Count++;
    }
};
  
int Human::Count = 0;
  
int main()
{
    // Create 3 Humans
    Human h1;
    Human h2;
    Human h3;

    // Check Counter
    cout << Human::Count << endl;
   
    return 0;
}
```

داخل کد بالا اول یک ویژگی استاتیک به اسم `Count` تبدیل کردیم که قراره تعداد آبجکت های ساخته شده رو برای ما نگهداری کنه. بعد از اون متد سازنده رو تعریف کردیم و داخل بدنه ی اون فقط به `Count` یک واحد اضافه کردیم.

بعد از تعریف کلاس هم حواسمون هست که `Count` استاتیک بوده و الان باید تعریفش کنیم اینجا تا بتونیم ازش استفاده کنیم.

در نهایت داخل بدنه ی اصلی برنامه مون 3 تا آبجکت از نوع `Human` ساختیم و مقدار `Count` رو توی ترمینال چاپ کردیم که در خروجی عدد 3 رو خواهیم دید.

این صرفا یه مثال جالب بود که با ماهیت متد کانستراکتور بیشتر آشنا بشید.

حالا که یک آشنایی کلی با این متد پیدا کردید می خوایم داخل تعریف کانستراکتور کلاسمون یه سری ورودی هم بگیریم.

یکی از کار هایی که برای ساده تر شدن تعریف آبجکت ها انجام میدن اینه که از کانستراکتور برای مشخص کردن ویژگی های آبجکت استفاده می کنن تا سریع تر بتونن آبجکت رو بسازن و مقدار دهی کنن.

برای اینکار ما به متد سازنده مون یه سری ورودی ها میدیم و موقع ساختن آبجکت هامونم حواسمون هست که مطابق کد زیر اون ورودی هارو کامل و به ترتیب وارد کنیم تا آبجکتمون ساخته بشه.

کد زیر رو برای پیاده سازی هدف بالا نوشته شده :
```cpp
class Car {        // The class  
  public:          // Access specifier  
    
    string Brand;  // Attribute  
    string Model;  // Attribute  
    int Year;      // Attribute  
    
    Car(string brand, string model, int year) 
    { 
	  // Constructor with parameters  
      Brand = brand;  
      Model = model;  
      Year = year;  
    }  
};  
  
int main() {  
  // Create Car objects and call the constructor with different values  
  Car carObj1("BMW", "X5", 1999);  
  Car carObj2("Ford", "Mustang", 1969);  
  
  // Print values  
  cout << carObj1.brand << " " << carObj1.model << " " << carObj1.year << "\n";  
  cout << carObj2.brand << " " << carObj2.model << " " << carObj2.year << "\n";  
  return 0;  
}
```
در ابتدای کد متد سازنده رو خیلی عادی تعریف کردیم و یه سری ورودی هم براش تعریف کردیم که داخل بدنه اش گفتیم اون ورودی هارو داخل ویژگی های اون آبجکت بریزه تا آبجکتمون با مقادیر اولیه ساخته بشه.

در ادامه وارد بدنه ی اصلی برنامه که بشیم میبینیم که برای دادن ورودی ها به کانستراکتور باید داخل پرانتز جلوی اسم آبجکتمون مقادیر رو به ترتیبی که تعریف کردیم وارد کنیم.

برای اینکه ببینیم کدمون درست کار کرده یا نه هم مقادیر ذخیره شده داخل هر آبجکت رو پرینت می کنیم و میبینیم که آبجکت هامون به درستی مقدار دهی شدن.

حالا که با این موضوع آشنا شدیم میریم که این یکی برنامه رو بهتر از قبلی پیاده سازی کنیم!

# مثال 2 : مدیریت آزمون های قلمچی

از اونجایی که شاید یادتون رفته باشه دوباره از اول ماجرا رو تعریف می کنم و یه دور ماجرا رو تحلیل می کنیم و میریم که پیاده سازیش کنیم.

آقای کاظم قلمچی اومده به ما گفته که براش یه برنامه درست کنیم تا اطلاعات تمام کلاس هایی که داره و میتونه توشون آزمون برگزار کنه رو داخلش ذخیره کنه و علاوه بر اون اطلاعات دانش آموز هایی که قرار وارد هر کلاس بشن رو هم ذخیره کنیم داخل این برنامه.

مشخصات هر کلاس :
- شماره کلاس
- ظرفیت کلاس
- دانش آموزان کلاس

مشخصات هر دانش آموز :
- کد ملی
- نام
- نام خانوادگی
- حوزه امتحانی

گفتیم که روندی که در عدم حضور برنامه ی ما پیش میره اینجوریه که اول اطلاعات کلاس هارو بررسی می کنن و بعد از اون میان و دانش آموزان رو بین کلاس هایی که دارن تقسیم می کنن.

کاری که برنامه ی ما باید انجام بده اینه که اطلاعات کلاس هارو داشته باشه و دانش آموزانی که ساخته میشن رو داخل کلاس ها تقسیم کنه.

خب برای شروع میتونیم کلاس هامونو با ویژگی هاشون تعریف کنیم. و یک متد کانستراکتور هم برای راحت تر کردن مقدار دهی ویژگی های آبجکت ها برای کلاس هامون بزاریم :

```cpp
class ClassRoom
{
public:
    string Code;
    int Capacity;
    vector<Student> Students;
};
  
// Student Class
class Student
{
public:
    string NationalCode;
    string Name;
    string Family;
    ClassRoom ExamClass;
  
    // Constructor
    Student(string nationalCode , string name , string family)
    {
        NationalCode = nationalCode;
        Name = name;
        Family = family;
    }
};
```

علت اینکه برای کلاس `ClassRoom` متد کانستراکتور نذاشتیم اینه که همون لحظه ای که دانش آموز جدید ساخته میشه نمی خوایم کلاسش رو مشخص کنیم و بعد از اینکه دانش آموز ساخته شد می خوایم با صدا زدن یک تابع دیگه یک کلاس براش پیدا کنیم. اینجوری دیگه لازم نیست که حتما یک دانش آموز حوزه ی آزمون داشته باشه و حالا به هر دلیلی نخواد سر حوزه ی آزمون حاضر بشه.

داخل کد بالا یه مشکلی وجود داره که برای حل کردنش لازمه یه مطلبی که داخل قسمت Function ها داشتیم رو یاد آوری کنیم.

داخل کلاس `ClassRoom` ما یک ویژگی که یک لیست از دانش آموزا هست رو داریم. در صورتی که کلاس دانش آموزان رو بعد از اون تعریف کردیم و این کار باعث میشه که ما به مشکل بخوریم. برای حل این مشکل باید از Declaration یا اعلان گذاری استفاده کنیم.

یعنی قبل از اینکه بیایم کلاس هارو تعریف کنیم اونارو به برنامه معرفی کنیم و بعدا اونارو تعریف کنیم.
این کار داخل بخش توابع معرفی شد ولی اونجا نیازی بهش پیدا نکردیم. داخل چنین مواقعی که مثل مثال بالا ما لازم داریم که داخل کلاس قبلی از کلاس بعدی استفاده کنیم از این روش استفاده میشه.

برای اعلان کردن کلاس ها کافیه که از سینتکس زیر استفاده کنیم :

```cpp
class ClassName;
```

پس با اعلان گذاری میایم و مشکل کد بالا رو حل می کنیم.

```cpp
// Declare Classes
class ClassRoom;
class Student;

// Class Room Class
class ClassRoom
{
public:
    string Code;
    int Capacity;
    vector<Student> Students;
};
  
// Student Class
class Student
{
public:
    string NationalCode;
    string Name;
    string Family;
    ClassRoom ExamClass;
  
    // Constructor
    Student(string nationalCode , string name , string family)
    {
        NationalCode = nationalCode;
        Name = name;
        Family = family;
    }
};
```

تا اینجا طبق روال همیشگی اومدیم و کلاس هامونو تعریف کردیم. حالا باید بریم سراغ پیاده سازی منطق برنامه و توابعی که داخل برنامه نیاز داریم.

بر میگردیم به روندی که وجود داشت. قرار شد اول یکسری کلاس ها به عنوان حوزه ی آزمون ثبت بشن. پس یعنی ما یه لیست نیاز داریم که حوزه هامونو برامون نگه داره. این کارو رو داخل مثال قبل برای انبار کامپیوتر هامون اجرا کردیم. اینجا هم همین کارو انجام میدیم و یک لیست استاتیک از کلاس هارو داخل `ClassRoom` قرار میدیم.

برای دانش آموزان به یک تابع نیاز داریم که اونارو به کلاسی که خالی باشه اضافه کنه. پس در کل میتونیم یک تابع داخل `ClassRoom` داشته باشیم که یک دانش آموز رو به عنوان ورودی بگیره و اونو ثبت نام کنه داخل هر کلاسی که خالی بود.

برای این کار میتونیم از یک تابع static استفاده کنیم چون این تابع وابسطه به یکی از کلاس ها نیست و قراره بگرده و کلاسی که خالیه رو پیدا کنه و در نهایت دانش آموز رو به اون کلاس اضافه کنه.

این تیکه رو بنویسیم بعد بریم سراغ ادامه اش :

```cpp
// class declaration :
class ClassRoom;
class Student;
  
// Class Room Class
class ClassRoom
{
public:
    string Code;
    int Capacity;
    vector<Student> Students;
  
    static vector<ClassRoom> ClassRooms;
  
    static void Register(Student std);
};
  
vector<ClassRoom> ClassRoom::ClassRooms;
  
// Student Class
class Student
{
public:
    string NationalCode;
    string Name;
    string Family;
    ClassRoom ExamClass;
  
    // Constructor
    Student(string nationalCode, string name, string family)
    {
        NationalCode = nationalCode;
        Name = name;
        Family = family;
    }
};
  
void ClassRoom::Register(Student std)
{
    // Find Empty class room
    int Index = 0;
    for (ClassRoom c : ClassRooms)
    {
        if (c.Capacity > c.Students.size())
        {
            break;
        }
        Index++;
    }
  
    // Add Student To Class Room
    if (ClassRooms.size() > Index)
    {
        ClassRooms[Index].Students.push_back(std);
    }
    else
    {
        cout << "We Don't Have Enough Space!" << endl;
    }
}
```

اون لیست استاتیکی که قراره حوزه های آزمون رو ذخیره کنه رو مثل قبل اومدیم و تعریف کردیم.

ما به یک تابع `Register()` نیاز داریم که یک `Student` رو ورودی بگیره و اونو به یکی از کلاس هامون اضافه کنه و اگر جا نبود بگه جا نیست تا بعدا آقای قلمچی براش یه فکری کنه.

اگر بخوایم متد `Register()` رو خیلی عادی داخل کلاس `ClassRoom` تعریف کنیم با یه مشکل مواجه میشیم و اونم اینه که داخل متد رجیستر با به تعریف `Student` نیاز داریم ولی این کلاس صرفا اعلان شده و هنوز تعریف نشده داخل اون بخش. برای همین باید تعریف این تابع رو به بعد از تعریف کلاس `Student` منتقل کنیم.

همونطور که ما میتونستیم توابع رو بیرون از کلاس ها اول declare کنیم و بعد اونارو تعریف کنیم، داخل کلاس ها هم میتونیم اونارو اول اعلان کنیم و بعد تعریفشون کنیم. سینتکس انجام دادن این کار هم به صورت زیر هست :

```cpp
class MyClass {        // The class  
  public:              // Access specifier  
    void myMethod();   // Method/function declaration  
};  
  
// Method/function definition outside the class  
void MyClass::myMethod() {  
  cout << "Hello World!";  
}
```

که داخل کد مثال هم از همین روش برای تعریف کردن متد `Register()` که استاتیک هم بود استفاده کردیم.

> ما اومدیم و متد `Register()` رو داخل کلاس `ClassRoom` قرار دادیم اما میتونستیم هم اونو داخل کلاس `Student` بزاریم و این تصمیمش به عهده ی شماست که کجا بزارید که مرتبط تر باشه.

کاری که داخل متد `Register()` انجام دادیم اینه که اول بیاد و یک کلاس خالی رو پیدا کنه و بعد ایندکس اون کلاس خالی رو که پیدا کردیم میایم و هم اون کلاس رو داخل ویژگی ExamClass دانش آموزمون میریزیم و هم اون دانش آموز رو به لیست دانش آموزان اون کلاس اضافه می کنیم. این جوری ما یک رابطه ی یک به چند بین این دو تا آبجکت ایجاد کردیم که از طریق هرکدوم میتونیم به آبجکت مرتبطش دست پیدا کنیم.

در نهایت وارد بدنه ی اصلی برنامه مون میشیم تا کد هایی که برای کلاس هامون نوشتیم رو تست کنیم :

```cpp
int main(){
    // Create Class Rooms and Add them To Class Rooms List
    ClassRoom c1{"001", 2};
    ClassRoom::ClassRooms.push_back(c1);
    ClassRoom c2{"002", 1};
    ClassRoom::ClassRooms.push_back(c2);
  
    // Create Student
    Student s1("121212", "Ali", "Seifi");
    Student s2("131313", "Mohammad", "Bagheri");
    Student s3("141414", "Maryam", "Hosseini");
    Student s4("151515", "Narges", "Ahmadi");
  
    // Register the Students
    ClassRoom::Register(s1);
    ClassRoom::Register(s2);
    ClassRoom::Register(s3);
    ClassRoom::Register(s4); // there is not Enough Space for 4 Student
  
    // Show Classes Information
  
    // Class 1 :
    cout << "Class 1 Students : " << endl;
    for (auto s : ClassRoom::ClassRooms[0].Students)
    {
        cout << s.NationalCode << " - " << s.Name << " - " << s.Family << endl;
    }
  
    // Class 2 :
    cout << "Class 2 Students : " << endl;
    for (auto s : ClassRoom::ClassRooms[1].Students)
    {
        cout << s.NationalCode << " - " << s.Name << " - " << s.Family << endl;
    }
  
    return 0;
}
```

این بار برای تعریف کردن آبجکت هامون از روش جدیدی استفاده کردیم که همون موقع ساخته شدن مقدار دهیشونم کردیم.

این کاری که کردیم دقیقا همون کار کانستراکتور رو انجام نمیده ولی یکی از کار هایی که کانستراکتور انجام میده رو میشه به این روش انجام داد و سریع تر داخل یک خط مقدار دهی آبجکت رو انجام داد. ترتیب وارد کردن مقادیر هم به ترتیب تعریف ویژگی هاش داخل کلاس هست.

مجموع فضا های کلاس ما 3 تا هست ولی ما 4 تا دانش آموز داریم پس انتظار داریم که داخل خروجی یک بار با پیام فضای کافی موجود نیست مواجه بشیم.

و لیست دانش آموزانی که داخل کلاس ها هستند رو هم مشاهده کنیم. (یعنی همه ی دانش آموزان به جز s4)

در خروجی این برنامه داریم :

```output
We Don't Have Enough Space!
Class 1 Students :
121212 - Ali - Seifi
131313 - Mohammad - Bagheri
Class 2 Students :
141414 - Maryam - Hosseini
```

به واسطه ی این دو مثال نهایی که داخل این قسمت و قسمت قبل حل کردیم تا حد خوبی با مفاهیم ابتدایی شی گرایی آشنا شدید.

اما همونطور که داخل قسمت قبل گفته بودیم داخل این قسمت می خوایم ببینیم که دلیل گذاشتن کلید واژه ی `public` قبل از تعریف کردن ویژگی ها و توابع کلاسمون چی بوده.

# Access Modifiers in C++

داخل سی پلاس پلاس مفهومی به اسم Access Specifier یا Access Modifier وجود داره که ما با استفاده از اون میتونیم تایین کنیم که هر ویژگی یا تابعی از چه بخش هایی از برنامه در دسترس باشه.

برای مثال برخی از توابع فقط قراره داخل محدوده ی خود کلاسمون استفاده بشن. (توابعی که فقط خود توابع داخل کلاس می خوان ازشون استفاده کنن.)

یا برعکس بعضی از توابع لازمه که داخل بدنه ی اصلی برنامه یا حتی کلاس های دیگه هم صدا زده بشن که ما برای تمیز تر شدن و قانونمند تر شدن برنامه مون میایم و این دو دسته از توابع رو از هم جدا می کنیم.

> داخل این قسمت با دو تا از تعیین کنندگان سطوح دسترسی آشنا میشیم و داخل قسمت بعد وقتی با وراثت آشنا شدید با سومین تعیین کننده هم آشنا خواهیم شد.

دو تا از پر استفاده ترین Access Specifier ها عبارتند از :
- public : از همه ی نقاط برنامه قابل دسترس هستند
- private : فقط داخل همون اسکوپ (همون کلاس) قابل دسترس هستند

داخل سی پلاس پلاس اگر از کلید واژه ی public استفاده نکنیم به صورت پیش فرض ویژگی ها و توابع private تعریف خواهند شد. ولی بهتره که برای خوانایی بیشتر کد کلید واژه ی private رو هم بنویسیم.

طرز استفاده از Access Modifier ها به صورت زیره :

```cpp
class MyClass {  
  public:    // Public access specifier  
    int x;   // Public attribute  
  private:   // Private access specifier  
    int y;   // Private attribute  
};  
  
int main() {  
  MyClass myObj;  
  myObj.x = 25;  // Allowed (public)  
  myObj.y = 50;  // Not allowed (private)  
  return 0;  
}
```

که داخل خط سوم از بدنه ی اصلیمون با ارور مواجه میشیم چون دسترسی به ویژگی y پرایوت هست و ما نمیتونیم داخل بدنه ی اصلی برنامه مون بهش دسترسی داشته باشیم.

شاید براتون سوال باشه که چرا ما باید دسترسی یک ویژگی رو محدود کنیم؟

داخل پروژه های بزرگتر که افراد به صورت تیمی روی یک برنامه کار می کنن یا پروژه های اوپن سورس که افراد زیادی قراره مشارکت کنن، ما با استفاده از این تایین سطوح دسترسی میایم و مشخص می کنیم که داخل این برنامه (یا کلاس) کدوم یکی از ویژگی هاش لازمه که از بیرون از کلاس تغییر پیدا کنه و کدوم یکی از ویژگی ها قرار نیست از بیرون از کلاس تغییر پیدا کنه و صرفا قراره داخل خود کلاس ازش استفاده بشه.

این کار باعث میشه که بعضی از ویژگی ها مقدارشون به صورت دستی عوض نشه و داخل کارکرد برنامه اختلال ایجاد نکنه.

داخل قسمت های بعد هم با مفهومی به اسم Encapsulation آشنا میشید و بهتر متوجه کاربرد این سطوح دسترسی خواهید شد.

تا اینجا با مفاهیم پایه ای شی گرایی آشنایی کامل پیدا کردید و از اینجا به بعد میریم سراغ مفاهیم پیچیده تر شی گرایی.

کم کم داریم به انتهای جزوه هم نزدیک میشیم. از اونجایی که قرار نیست تمام منبع شما برای یادگیری برنامه نویسی این جزوه باشه یک بخش از این قسمت رو می خوام یادگیریش رو به عهده ی خودتون بزارم تا با سرچ کردن و به دست آوردن مطالبی که به گوشتون می خورن بیشتر آشنا بشید.

ما تا اینجا با متد سازنده یا Constructor آشنا شدیم. اما بعد از اینکه کار ما با اون آبجکت تموم میشه و دیگه دستوری روی اون آبجکت قرار نیست اجرا بشه اون آبجکت از بین میره. وقتی که آبجکت از بین میره همونطور که موقع ساخته شدنش متد کانستراکتور اجرا شد موقع خراب شدنش هم متدی به اسم destructor اجرا میشه که از شما می خوام خودتون برید و طرز پیاده سازیش رو در بیارید.

به عنوان تمرین هم میتونید یک برنامه بنویسید که آبجکت های موجود رو بشماره و هر بار که آبجکتی ساخته یا خراب میشه هم یک پیام نمایش بده و تعداد آبجکت های موجود رو اعلام کنه.

کد های این قسمت رو هم میتونید از اینجا ببینید : [Examples](Program.cpp)