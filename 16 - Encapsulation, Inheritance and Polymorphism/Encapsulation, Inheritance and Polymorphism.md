
# مقدمه

داخل قسمت های قبلی با مفاهیم اولیه ی کلاس ها و شی گرایی داخل سی پلاس پلاس آشنا شدید. همونطور که گفتیم مفاهیم شی گرایی برای این استفاده میشن که پروژه کد های واضح تری داشته باشه و توسعه ی اون راحت تر بشه.

داخل این قسمت قراره با مفاهیم پیشرفته تر شی گرایی آشنا بشیم تا بتونیم پروژه رو بهتر تحلیل کنیم و قابلیت توسعه ی اونو افزایش بدیم.

# Encapsulation

یک سری از ویژگی ها هستن که قرار نیست کسی به صورت مستقیم به اونا دسترسی داشته باشه و دسترسی اجزاء دیگه ی برنامه به اون از طریق یک تابع واسط هست. اگر ما بیایم و برای اون ویژگی یا یا همون `Attribute` دو تا تابع در نظر بگیریم که یکی از اون توابع برای ست کردن مقدار اون ویژگی و دیگری برای خوندن اون ویژگی باشن اصطلاحا ما این ویژگی رو کپسوله کردیم و از مفهومی به اسم Encapsulation کمک گرفتیم.

اگر بخوایم در واقعیت مثالی از این مورد بزنیم میشه ویژگی معده ی یک سگ رو در نظر گرفت که مستقیما به اون دسترسی ای وجود نداره ولی وقتی که غذایی بخوره (تابع غذا خوردن) اون کار باعث میشه که غذا به معده اش منتقل بشه. حالا برای اینکه در نهایت خروجی اون غذا چطور دیده میشه زیاد وارد جزئیات نمیشیم.

ولی در کل از این مفهوم برای وقتی استفاده میشه که ما نمی خوایم کسی به اون ویژگی دسترسی مستقیم داشته باشه. برای مثال ما داخل برنامه ای که برای بانک نوشتیم نمی خوایم که مقدار پولی که شخص مورد نظر به حسابش واریز کرده به طور کامل به مقدار داراییش اضافه بشه و قبل از اون مقداری از اون به عنوان مالیات کم بشه و بعد وارد حساب بشه.

در چنین مواقعی از مفهومی به اسم encapsulation استفاده می کنیم تا بتونیم روی ورودی و خروجی ای که به اون ویژگی داده میشه دخل و تصرف داشته باشیم. ویژگی ای که کپسوله شده باشه رو بهش `Property` گفته میشه و دیگه `Attribute` نیست.

حالا که با مفاهیم نظری این مورد آشنا شدیم بریم و داخل عمل ببینیم که چطور باید پیاده سازیش کنیم :

```cpp
#include <iostream>

class BankAccount {
private:
    int balance; // Private member variable to store the account balance

public:
    BankAccount(int initialBalance) { // Constructor to initialize the balance
        if (initialBalance >= 0) {
            balance = initialBalance;
        } else {
            std::cout << "Error: Initial balance cannot be negative." << std::endl;
            balance = 0;
        }
    }

    // Getter method to retrieve the balance in a controlled manner
    int getBalance() const {
        return balance;
    }

    // Setter method to modify the balance with validation (optional)
    void deposit(int amount) {
        if (amount > 0) {
            balance += amount;
            std::cout << "Deposit successful." << std::endl;
        } else {
            std::cout << "Error: Deposit amount cannot be negative." << std::endl;
        }
    }
};

int main() {
    BankAccount account(100); // Create an account with an initial balance of 100
    std::cout << "Current balance: " << account.getBalance() << std::endl;
    account.deposit(50); // Deposit 50
    std::cout << "Balance after deposit: " << account.getBalance() << std::endl;
    // Attempting to directly access or modify balance is prevented (uncomment to see)
    // account.balance = -100; // This would cause a compilation error
    return 0;
}
```

ویژگی ای که همیشه پابلیک تعریف می کردیم رو اینبار پرایوت تعریف می کنیم و به جای اون دو تا تابع برای گرفتن مقدار اون و ست کردن مقدار اون اضافه می کنیم.
به این دو توابع اصطلاحا `Setter` و `Getter` گفته میشه که داخل کد با کامنت مشخص شده هرکدومش کدومه.

داخل کد بالا همون مثال حساب بانکی رو پیاده سازی کردیم. ویژگی `balance` رو پرایوت تعریف کردیم و داخل توابع پابلیک دو تابع `getBalance()` به عنوان `Getter` و `deposit(int amount)` به عنوان `Setter` رو تعریف کردیم و قراره از این به بعد فقط از طریق این توابع به ویژگی `balance` دسترسی داشته باشیم.

یک تابع کانستراکتور هم برای تعیین مقدار اولیه ی حساب درست کردیم که مقدار دهی اولیه هم از طریق اون انجام بشه.

داخل بدنه ی اصلی برنامه هم ابتدا یک حساب بانکی ساختیم که 100 واحد پول داخلشه و با استفاده از تابع `getBalance()` مقدار اونو نمایش دادیم و با استفاده از تابع `deposit()` هم مقداری پول به حساب واریز کردیم و در نهایت دوباره موجودی حساب رو نمایش دادیم.

در کل برای کپسوله کردن یک ویژگی باید از این روش استفاده بشه.

# Inheritance

یکی دیگه از مواردی که داخل برنامه نویسی شی گرایی خیلی مهم و پر کاربرده بحث وراثت یا `Inheritance` هست.

یه وقتایی هست که کلاس هایی که توی برنامه مون تعریف می کنیم یه سری ویژگی های مشترک باهم دیگه دارن و این ویژگی ها تکرار شده. اینجا میتونیم حدس بزنیم که پای وراثت در میونه و احتمالا میشه یک کلاس والد برای این دو کلاس در نظر گرفت.

داخل برنامه نویسی شی گرا یک کلاس میتونه از کلاس دیگه ای ارث بری کنه. در این صورت به کلاس اصلی میگن کلاس والد یا پدر (`Parent Class`) و به کلاسی که ارث بری کرده میگن کلاس فرزند(`Child Class`).

کلاس فرزند تمام ویژگی های غیر private رو از کلاس پدر خودش دارا میشه و دیگه نیازی نیست که اونارو دوباره داخل کلاس تعریف کنیم.

برای مثال برای مدیریت یک شرکت یک برنامه نوشتیم که اطلاعات مشتریان و کارمندان اون شرکت رو نگهداری می کنه. ویژگی هایی مثل نام ، نام خانوادگی و ... وجود دارن که بین مشتری و کارمند مشترک هستند و علت این هم این هست که هردوی اونا انسان هستند و یک سری ویژگی های مشترک دارن. پس ما میایم و یک کلاس والد تعریف می کنیم که ویژگی های مشترک رو شامل بشه و بعد کلاس های کارمند و مشتری رو از اون کلاس ابتداییمون ارث بری می کنیم تا ویژگی های اون رو شامل بشن.

برای ارث بری کردن یک کلاس از دیگری باید از سینتکس زیر استفاده کنید :
```cpp
// Base class
class Vehicle {
  public:
    string brand;
    void honk() {
      cout << "Tuut, tuut! \n" ;
    }
};

// Derived class
class Car: public Vehicle {
  public:
    string model;
};

```
برای ارث بری کردن با استفاده از علامت `:` و اسم کلاسی که می خوایم ازش ارث بری کنیم (یک `public` هم باید قبلش بنویسیم) مشخص می کنیم که کلاسمون قراره ارث بری کنه.

داخل کد بالا کلاس والد یا `Parent Class` یا `Base Class` اسمش `Vehicle` یا وسیله ی نقلیه هست که داخل ویژگی های خودش `brand` رو داره که همه ی وسایل نقلیه این برند رو دارن.

و کلاس فرزند یا `Child Class` یا `Derived Class` که از کلاس `Vehicle` ارث بری کرده اسمش `Car` هست که علاوه بر ویژگی های وسیله ی نقلیه یک ویژگی `model` هم داره که مدل اون ماشین رو مشخص می کنه.

الان تمام ویژگی ها و توابع کلاس `Vehicle` داخل کلاس `Car` هم قابل دسترس هستند و میتونیم بهشون مقدار بدیم :
```cpp
int main() {
  Car c1;
  c1.brand = "Ford";
  c1.model = "Mustang";
  c1.honk();
  cout << c1.brand + " " + c1.model;
    
  return 0;
}
```

در نظر داشته باشید که از نظر تعداد ارث بری کردن و این جور چیزا محدودیتی نداریم و همین باعث میشه که بتونیم کد های تمیز تری بنویسیم و از تکرار شدن کد ها جلوگیری کنیم.

حالا بیاید و اون مثال کارمند و مشتریان که اول این بخش زدیم رو پیاده سازی کنیم.

در ابتدا یک کلاس `Person` تعریف می کنیم که شامل ویژگی های یک انسان یا همون ویژگی های مشترک مشتری و کارمند میشه. و بعد کلاس های `Customer` و `Employee` رو که از کلاس `Person` ارث بری می کنن رو تعریف می کنیم :

```cpp
// Base Class (Person)
class Person{
	public:
		string Name;
		string Family;

};

// Derived Class (Employee)
class Employee : public Person{
	private:
		int Income;
	
	public:
		void SetIncome(int income){
			Income = income;
		}
		int GetIncome(){
			return Income;
		}
};

// Derived Class (Customer)
class Customer : public Person{
	public: 
		string PhoneNumber;
		void BuyProduct(){
			cout << Name << " bought something." << endl;
		}
};

int main()
{
	// Create an Employee
	Employee e1;
	e1.Name = "Ali";
	e1.Family = "Seifi";
	e1.SetIncome(120);

	cout << e1.Name << " " << e1.Family << " Income  : " << e1.GetIncome() << endl;
	
	// Create a Customer
	Customer c;
	c.Name = "Mohammad";
	c.Family = "Ghorbani";
	c.PhoneNumber = "09123456789";
	c.BuyProduct();
	return 0;
}
```

داخل کد بالا اول کلاس `Person` رو با ویژگی های نام و نام خانوادگی تعریف کردیم.

بعد از اون اومدیم و کلاس `Employee` رو که از کلاس `Person` ارث بری می کنه رو تعریف کردیم و ویژگی income رو براش گذاشتیم و اون ویژگی رو Encapsulate کردیم (اینجا خیلی دلیلی وجود نداشت که این کار رو انجام بدیم ولی برای ویژگی هایی که ممکنه در ادامه دخل و تصرفی داخلشون ایجاد بشه معمولا اونارو به این صورت تعریف می کنن تا شکل پروژه مشخص باشه.)

و در ادامه کلاس `Customer` رو به عنوان فرزند کلاس `Person` معرفی کردیم که یک ویژگی شماره تلفن و یک تابع خریداری کردن براش گذاشتیم (خیلی مبحث رو پیچیده نکردیم چون تحلیل کردن پروژه رو داخل قسمت قبلی گفتیم و مثال های نسبتا سختی رو حل کردیم.)

داخل بدنه ی اصلی برنامه هم اومدیم و کلاس هایی که تعریف کردیم رو یه مهک زدیم تا ببینیم همه چیز اونجوری که می خوایم کار می کنه یا نه. (که کار می کرد.)

## Multi-level Inheritance
همونطور که داخل بخش قبلی هم اشاره کردیم شما داخل ارث بری کردن محدودیتی از نظر تعداد ارث بری ندارید. برای همین میتونید داخل چند مرحله از یک کلاس ارث بری کنید یا 3 تا کلاس که به صورت خطی از هم دیگه ارث بری می کنن رو تعریف کنید. 

برای مورد اول که از یک کلاس چند بار ارث بری کنیم داخل بخش قبل مثال زدیم. حالا می خوایم برای یک سلسله وراثت هم یک مثال بزنیم تا باهاش آشنا بشید :

برای مثال لوازم الکترونیکی خونه رو فرض می کنیم.
ما در حالت کلی یکسری لوازم خانگی داریم. که زیر مجموعه ی اون لوازم خانگی میتونن لوازم الکترونیکی قرار بگیرن و در نهایت جاروبرقی میتونه زیرمجموعه ی لوازم الکترونیکی قرار بگیره.

```cpp
// Grand Parent Class
class Appliance
{
public:
    string Name;
};
  
// Parent Class
class EAppliance : public Appliance
{
public:
    int Voltage;
    void TurnOn()
    {
        cout << Name << " Turned On." << endl;
    }
};
  
// Child Class
class VacuumCleaner : public EAppliance
{
public:
    int Power;
};
```

اول از همه یک کلاس `Appliance` داریم که کلاس لوازم خانگی ما هست و کلاس والد ماست داخل این مثال. بعد از اون کلاس `EAppliance` رو داریم که کلاس لوازم الکترونیکی ماست و داخل ویژگی هاش یک ولتاژ داره و یک تابع `TurnOn()` هم داره. این کلاس همزمان هم فرزند کلاس `Appliance` هست و هم قراره والد کلاس جاروبرقی ما بشه. در نهایت یک کلاس `VacuumCleaner` داریم که فرزند کلاس `EAppliance` هست و علاوه بر ویژگی های اون کلاس یک ویژگی توان هم داره که توان مصرفی اونو نشون میده.

الان داخل مثال بالا کلاس `VacuumCleaner` هم شامل ویژگی هایی میشه که توی `EAppliance` هست و هم شامل ویژگی هایی میشه که توی `Appliance`  هست و تمام این ویژگی هارو به ارث برده.

در واقع میشه گفت شامل همه ی ویژگی های پدر خودش شده و پدرش هم شامل ویژگی های کلاس پدربزرگ میشه پس کلاس جاروبرقی شامل تمام این ویژگی ها خواهد شد.

این طریقه ی پیاده سازی وراثت چند مرحله ای یا سلسله ای بود. (Multi-Level Inheritance)

## Multiple Inheritance

بعضی وقتا هست که ما نیاز داریم کلاسمون از دو تا کلاس دیگه همزمان ارث بری کنه و به عبارتی کلاسمون دو تا کلاس والد داشته باشه.

در این موارد کلاس فرزند تمام ویژگی های والدین خودش رو به ارث میبره و اونارو شامل میشه.

برای پیاده سازیش باید به روش زیر عمل کنیم :

برای مثال دو کلاس برنامه نویس بکند و برنامه نویس فرانت اند رو داریم که برنامه نویسی که ویژگی های هردوی اینارو شامل بشه برنامه نویس فول استک میشه.

یعنی کدش به صورت زیر میشه :

```cpp
// Multipe Inheritance

// Base Class 1
class BackEndDev
{
public:
	string PL; // Programming Language
	void CreateBackEnd()
	{
		cout << "Backend Created" << endl;
	}
};

// Base Class 2
class FrontEndDev
{
	int jsLevel;
	void CreateFrontEnd()
	{
		cout << "FrontEnd Created" << endl;
	}
};

// Derived Class From Base Class 1 and Base Class 2
class FullStackDev : public BackEndDev, public FrontEndDev
{
public:
	void CreateWebsite()
	{
		cout << "Website Created" << endl;
	}
};
```

دو تا کلاس بکند دولوپر و فرانت اند دولوپر رو داریم که هرکدوم یک ویژگی و یک تابع دارن و در نهایت کلاس فول استک دولوپر از هر دوی اونا میاد ارث بری می کنه و علاوه بر اونا یک تابع اضافه هم داره.

برای اینکه ببینیم کدمون چیزی که نیاز داشتیم رو تامین کرده یا نه میایم و کار زیر رو انجام میدیم :

```cpp
int main()
{
	FullStackDev fsd;
	fsd.PL = "Python";
	fsd.jsLevel = 12;
	fsd.CreateBackEnd();
	fsd.CreateFrontEnd();
	fsd.CreateWebsite();

	return 0;
}
```

که با اجرا گرفتن از کدمون می فهمیم که به درستی کار می کنه.

## Protected Access Specifier

داخل قسمت های قبل با Access Modifier های `public` و `private` آشنا شدید. داخل بحث وراثت هم یک Access Specifier وجود داره که اون ویژگی رو فقط داخل خود کلاس و کلاس های فرزند اون در دسترس قرار میده.

با استفاده از کلید واژه ی `protected` میتونید این سطح دسترسی رو تایین کنید.

برای مثال ما می خوایم یک پروپرتی رو با چیزی که داخل بخش Encapsulation یاد گرفتیم درست کنیم اما این بار `setter` و `getter` اونو داخل کلاس فرزندش تعریف کنیم :

```cpp
// protected Access Specifier
class BaseClass
{
protected:
	int Status;
};

class DerivedClass : public BaseClass
{
public:
	int GetStatus()
	{
		return Status;
	}
	void SetStatus(int status)
	{
		Status = status;
	}
};
```

با استفاده از سطح دسترسی `protected` میتونیم داخل کلاس های فرزند هم به اون ویژگی دسترسی داشته باشیم ولی همچنان این ویژگی داخل بدنه ی اصلی برنامه و جاهای دیگه که از `BaseClass` ارث بری نکردند قابل دسترسی نیست.

> یه جورایی `private` میشه ولی برای کل خانواده

برای تست کردنش هم کد زیر رو توی بدنه ی اصلی برنامه مون مینویسیم ببینیم کار می کنه یا نه :

```cpp
int main(){
	// Protected Access Specifier
	DerivedClass dc;
	dc.SetStatus(404);
	cout << "Status : " << dc.GetStatus() << endl;

	return 0;
}
```

که این بخش هم با موفقیت کار می کنه و مشکلی پیش نمیاد.

# Polymorphism


داخل برنامه نویسی شی گرا مفهومی به اسم چند ریختی یا Polymorphism وجود داره که به ما کمک می کنه تا توابعی با نام های مشابه ولی کارکرد های مختلف داخل بخش های مختلف برنامه داشته باشیم.

دو روش برای پیاده سازی این مفهوم وجود داره که قبلا با یکی از این روش ها آشنا شدیم :
- Method Overloading
- Method Overriding

## Method Overloading

با متد آورلودینگ در قسمت 11 آشنا شدید. وقتی که ما چند تا تابع با نام های یکسان ولی امضا های مختلف تعریف کنیم میتونیم توابعی با یک نام ولی کارکرد های متفاوت داشته باشیم.

حالا داخل کلاس هامون هم میتونیم این سیستم رو پیاده سازی کنیم. برای مثال داخل یک کلاس به اسم Math که قراره به ما کمک کنه تا عملیات های ریاضی رو انجام بدیم قراره تابع توان تعریف های مختلفی داشته باشه :

```cpp
// Polymorphism
class Math
{
public:
	// Square Of x
	static int Pow(int x)
	{
		return x * x;
	}
	// x^n
	static int Pow(int x, int n)
	{
		int res = x;
		for (int i = 0; i < n - 1; i++)
		{
		    res *= x;
		}
		return res;
	}
};
```
داخل کد بالا ما یک کلاس به اسم `Math` تعریف کردیم که شامل دو تا تابع استاتیک میشه. برای این استاتیک تعریف کردیم که نیازی به ساختن instance نداشته باشه و همینجوری بتونیم ازشون استفاده کنیم.

بعد داخل کلاس با استفاده از مفهوم Method Overloading اومدیم و دو تا تابع با یک اسم ولی کارکرد های متفاوت تعریف کردیم که با توجه به ورودی های این تابع مشخص میشه که بدنه ی کدوم یکی باید اجرا بشه.

برای تست هم کد زیر رو مینویسیم :

```cpp
int main(){
    cout << Math::Pow(2) << endl;
    cout << Math::Pow(2, 10) << endl;

	return 0;
}
```

و در خروجی خواهیم داشت :
```output
4
1024
```


## Method Overriding
روش دیگه ای که میتونیم باهاش Polymorphism رو پیاده سازی کنیم استفاده کردن از Method Overriding هست. داخل این روش ما میایم و تفاوت کارکرد یک تابع رو داخل کلاس های مختلف متفاوت میزاریم.

برای مثال داخل کلاس والد تعریف یک چیز باشه ولی داخل کلاس های فرزند تعریف همون تابع متفاوت باشه. 

برای مثال به کد زیر دقت کنید :
```cpp
// Base class  
class Animal {  
  public:  
    void animalSound() {  
      cout << "The animal makes a sound \n";  
    }  
};  
  
// Derived class  
class Pig : public Animal {  
  public:  
    void animalSound() {  
      cout << "The pig says: wee wee \n";  
    }  
};  
  
// Derived class  
class Dog : public Animal {  
  public:  
    void animalSound() {  
      cout << "The dog says: bow wow \n";  
    }  
};  
  
int main() {  
  Animal myAnimal;  
  Pig myPig;  
  Dog myDog;  
  
  myAnimal.animalSound();  
  myPig.animalSound();  
  myDog.animalSound();  
  return 0;  
}
```

داخل این برنامه 3 تا کلاس داریم. یک کلاس `Animal` که والد هست و دو کلاس دیگه که کلاس های فرزند هستند به اسم `Pig` و `Dog` برای همه ی کلاس ها تابع `animalSound()` رو تعریف کردیم و هرکدوم تعاریف مختلفی دارن. در نهایت ما این تابع رو روی آبجکتی از هر نوع که صدا بزنیم تابع مربوط به همون نوع اجرا میشه.

به این روش method overriding گفته میشه که با استفاده از اون میتونیم داخل برنامه مون چند ریختی رو پیاده سازی کنیم.

---
به خوبی تونستیم مباحثی که داخل شی گرایی مطرح بودن رو یاد بگیریم. مباحث شی گرایی به چیزایی که توی این جزوه هستن محدود نمیشن و خیلی گسترده ترن. ولی از اونجایی که هدف این جزوه پوشش دادن درس های دانشگاهه فکر می کنم تا این مقدار شی گرایی کافی باشه و حتی شاید زیاد هم باشه.

داخل قسمت بعدی در مورد کار با فایل ها صحبت خواهیم کرد و میریم که اطلاعات برنامه مون رو یه جایی ذخیره کنیم تا بعد از بسته شدن برنامه مون هم بتونیم اون اطلاعات رو داشته باشیم.

---

کد های این قسمت رو هم میتونید از طریق این لینک ببینید و خودتون اجراشون کنید : [Examples](Program.cpp)