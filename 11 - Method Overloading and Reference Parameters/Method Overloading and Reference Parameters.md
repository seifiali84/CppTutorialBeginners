
# مقدمه

یکی از استفاده های پوینتر ها داخل پارامتر های توابع هست. ما به جای اینکه کل متغیر رو به عنوان ورودی به تابعمون بدیم میایم و فقط آدرس اون رو به تابع میدیم تا برنامه مون سریع تر کار کنه. داخل این قسمت این کار رو انجام میدیم و در ادامه با مفهومی به اسم `Method Overloading` یا `Function Overloading` آشنا میشیم و ازش استفاده می کنیم.

# استفاده از رفرنس برای پارامتر ها

برای اینکه یک ورودی رو با استفاده از رفرنس اون (آدرس اون توی رم) به تابعمون پاس بدیم اول باید داخل تعریف تابعمون بگیرم که قراره یک رفرنس رو به عنوان ورودی دریافت کنه و موقع استفاده کردن از تابع هم باید حتما یک متغیر رو به عنوان ورودی بهش بدیم و نمیتونیم مقدار اون رو مستقیما وارد کنیم.

به کد زیر دقت کنید :

```cpp
#include <iostream>
#include <string>

using namespace std;

void SayHi(string &Name){
	cout << Name << "\n";
}

int main(){
	string Name = "Ali";
	SayHi(Name);
	return 0;
}
```
تنها کاری که لازمه انجام بدیم برای استفاده از این روش اینه که یک علامت `&` پشت اسم متغیر ورودی تابع قرار بدیم.

خب تا اینجا احتمالا براتون سوال شده که چرا ما باید به جای پاس دادن ورودی در حالت عادی از این روش استفاده کنیم.
برای اینکه بهتر متوجه کاربرد این روش بشید یه آزمایش انجام میدیم.

برای انجام تست از سایت [RexTester]("https://rextester.com/l/cpp_online_compiler_gcc") استفاده می کنیم که تایمی که طول میکشه تا برنامه اجرا بشه رو بهمون میگه و میتونیم دو تا برنامه رو با هم دیگه مقایسه کنیم.

ما دو تا فانکشن زیر رو تعریف می کنیم :
```cpp
string SayHi(string &Name){
	return "Hi " + Name;
}

string SayHi2(string Name){
    return "Hi " + Name;
}
```
داخل تابع اول ما میایم ورودی رو از طریق آدرس اون دریافت می کنیم و داخل تابع دوم میایم و ورودی رو معمولی دریافت می کنیم.

حالا می خوایم هر دو تا فانکشن رو تست کنیم ببینیم کدومشون زمان بیشتری برای اجرا شدن نیاز داره.

چون سرعت کامپیوتر خیلی زیاده ما برای مقایسه ی این دو تا فانکشن تعداد تکرار اونارو بیشتر می کنیم و بعد داخل ابعاد بزرگ اونارو باهم دیگه مقایسه می کنیم.

اول فانکشن اول رو اجرا می کنیم که از رفرنس استفاده کرده :
```cpp
	string Name = "Ali";
    for(int i = 0; i < 100000000; i++)
    {
        SayHi(Name);
    }
    return 0;
```

نتیجه :

```Result
absolute running time: 2.34 sec
cpu time: 3.43 sec
```

تعریف :
`Absolute Running Time` : زمانیه که اجرا شدن برنامه طول کشیده
`cpu time` : زمانیه که برنامه در حال پردازش با استفاده از سیپیو بوده

حالا میایم و همین برنامه رو اینبار با فانکشن دومی اجرا می کنیم :
```cpp
	string Name = "Ali";
    for(int i = 0; i < 100000000; i++)
    {
        SayHi2(Name);
    }
    return 0;
```

نتیجه :
```Result
absolute running time: 3.04 sec
cpu time: 4.47 sec
```
اختلاف سرعت اجرا داخل هردو واضحه.

معمولا کاربرد زبان هایی مثل سی پلاس پلاس و سی داخل همین چند میکروثانیه(شاید حتی خیلی کمتر) زمان اجرای کمتریه که میتونن به واسطه ی پوینتر ها داشته باشن و داخل موارد خاص این زمان های کوتاه خیلی مهم میشن.

# Method Overloading
متد آورلودینگ یا فانکشن آورلودینگ (Function Overloading) مفهومی هست که به ما اجازه میده که تابعی که داریم مینویسیم رو بیشتر توسعه بدیم و کاری کنیم که در حالت های بیشتری جواب بده.

برای مثال من یک تابع دارم که اگر ورودی به اون دو تا عدد بدیم اونارو باهم جمع می کنه و به عنوان خروجی به من برمیگردونه.
حالا می خوام کاری کنم که اگر یه نفر به همون تابع دو تا `string` به عنوان ورودی داد بازم تابع کار کنه ولی این بار اون دو تا string رو با هم جمع کنه و با استفاده از یک فضای خالی از هم جدا کنه.

اگر بخوایم دقیق تر تعریف کنیم :
با استفاده از متد آورلودینگ میتونیم تعدادی فانکشن با نام های یکسان ولی تعریف های مختلف داشته باشیم.

اختلاف این توابع رو ورودی های اونا هستن که مشخص می کنن 

برای استفاده از این مفهوم به کد زیر دقت کنید:
```cpp
int Sum(int Num1 , int Num2){
	return Num1 + Num2;
}
string Sum(string text1 , string text2){
	return text1 + " " + text2;
}
int main(){
	cout << Sum(10 , 20) << "\n";
	cout << Sum("Ali" , "Seifi") << "\n";
	return 0;
}
```
خروجی :
```Output
30
Ali Seifi
```
همونطور که می بینید ما تابع Sum رو صدا زدیم ولی تابع Sum با توجه به ورودی هایی که به اون میدادیم عمل می کنه و با توجه به تعاریفی که داره کاری که براش مشخص شده رو انجام میده.

تعداد این توابع هرچند تا که بخوایم میتونه باشه و فقط کافیه که ورودی های متفاوتی از همدیگه داشته باشن.

# توابع بازگشتی

یکی از انواع تابعی که میشه تعریف کرد تابع بازگشتی هست.
داخل این نوع تابع ما میایم داخل خود تابع از خودش استفاده می کنیم و این باعث میشه که تابع داخل یک چرخه قرار بگیره و کار رو چند بار انجام بده.

مثال مرسومی که وجود داره تابع فاکتوریل هست که با این روش نوشته میشه.
برای درست کردن یک تابع بازگشتی فقط کافیه که داخل بخشی از تابع دوباره از خود تابع استفاده کنیم و با استفاده از یک شرط یه جایی اون تابع رو به پایان برسونیم.

برای مثال تابعی می خوایم بنویسیم که هر عددی بهش دادیم تمام اعداد طبیعی قبل از خودش رو باهم جمع کنه :

```cpp
int sum(int k) {  
  if (k > 0) {  
    return k + sum(k - 1);  
  } else {  
    return 0;  
  }  
}
int main(){
	cout << sum(4) << "\n"; // 4 + 3 + 2 + 1
	return 0;
}
```
روندی که داخل تابع داره پیش میاد رو مرحله به مرحله بررسی می کنیم تا بهتر متوجه بشید :

با عدد 3 مثال میزنیم :
1- عدد 3 وارد تابع میشه
2- عدد بزرگتر از 0 هست پس وارد if میشیم.
3- عدد 3 با sum(2) که یکی کمتر از 3 هست جمع میشه.
4- حالا دوباره وارد تابع میشیم و sum(2) حساب میشه.
5- باز همین تکرار میشه و اینبار موقع خروجی گرفتن sum(1) اجرا میشه
6- در نهایت که به sum(0) میرسیم عدد 0 خروجی داده میشه و این حلقه شکسته میشه.

برای اینکه بهتر متوجه بشید به عکس زیر دقت کنید :
![Function Recursion Example](<Function Recursion Example.png>)

طرز کار مشابهی با توابع بازگشتی در ریاضیات داره.

برای اینکه بیشتر جا بیوفته تابع فاکتوریل رو هم با استفاده از همین روش پیاده سازی می کنیم :

```cpp
int Factorial(int number){
	if(number > 0){
		return number * Factorial(number - 1);
	}
	else {
		return 1;
	}
}

int main(){
	cout << Factorial(3) << "\n"; // 3 * 2 * 1
	return 0;
}
```

برای تمرین میتونید کاری که تابع بالا انجام میده رو برای عدد سه مثل عکس بالا بکشید تا بهتر متوجه اتفاقی که میوفته داخل این تابع بازگشتی بشید.

در کل توابع داخل برنامه نویسی بحث مفصلی داره و به مرور زمان یاد میگیرید که هرجایی از چه تابعی باید استفاده کنید و چطور با استفاده از این توابع میتونید کدتون رو خوانا تر و تمیز تر کنید.
